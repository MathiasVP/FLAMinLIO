
{-
leasts :: Set (Labeled FLAM (Principal, Principal)) -> ReaderT Trace (LIO H FLAM) (Set (Labeled FLAM (Principal, Principal)))
leasts as = filterM extremal (Set.toList as) >>= return . Set.fromList
  where
    extremal :: Labeled FLAM (Principal, Principal) -> ReaderT Trace (LIO H FLAM) Bool
    extremal a = do
      let as' = Set.filter (/= a) as
      {-zzz <- ask
      lift $ LIO . StateT $ \s -> do
        putStrLn $ "Trace before allM: " ++ show zzz
        putStrLn $ "Element:\n" ++ show a
        putStrLn $ "Original set:\n" ++ show as
        putStrLn $ "Filtered set:\n" ++ show as'
        putStrLn ""
        return ((), s)-}
      allM (\lab -> do
               lift $ LIO . StateT $ \s -> do
                 putStrLn $ "Candidate: " ++ show (labelOf a)
                 putStrLn $ "Element: " ++ show (labelOf lab)
                 putStrLn ""
                 return ((), s)
               lift $ labelOf a âŠ‘ labelOf lab
           ) (Set.toList as')
-}

{-
climb :: Set (Labeled FLAM (Principal, Principal)) ->
         (Set (Labeled FLAM (Principal, Principal)) ->
           ReaderT Trace (LIO H FLAM) Bool) ->
 ReaderT Trace (LIO H FLAM) Bool
climb s f = doClimb s Set.empty
  where
    doClimb :: Set (Labeled FLAM (Principal, Principal)) -> Set (Labeled FLAM (Principal, Principal)) -> ReaderT Trace (LIO H FLAM) Bool
    doClimb _ s' | s' == s = f s'
    doClimb s s' = do
      smin <- leasts s
      lift $ LIO . StateT $ \zzz -> do
        print smin
        return ((), zzz)
      f s' <||> doClimb (s \\ smin) (s' `Set.union` smin)
-}